<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Happy Anniversary ‚Äî Jigsaw (90 pieces)</title>
<style>
:root{
  --bg1:#ffd6ec; --bg2:#d6f0ff; --accent:#e60073; --accent-soft:#ff80bf;
  --card:#fff; --rose-border:#ffe0ef; --danger:#ff4d6d; --good:#48d28a;
}
*{box-sizing:border-box}
body{
  margin:0; font-family:Inter, "Segoe UI", system-ui, Arial, sans-serif;
  background:linear-gradient(135deg,var(--bg1),var(--bg2));
  -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  color:#222;
  min-height:100vh;
  display:flex;align-items:center;justify-content:center;padding:22px;
}

/* HOME / APP CARD */
.card{
  width:960px; max-width:96%; background:var(--card); border-radius:16px;
  padding:22px; border:4px solid var(--rose-border); box-shadow:0 14px 40px rgba(0,0,0,0.12);
}
.header{display:flex;align-items:center;gap:16px;justify-content:space-between}
.title{color:var(--accent); font-size:22px; margin:0}
.subtitle{color:#444;font-size:14px;margin-top:6px}

/* play area */
.main{display:flex;gap:18px;margin-top:14px;align-items:flex-start}
.left{flex:1}
.right{width:230px;min-width:180px}

/* board wrapper */
.board-wrap{
  background:linear-gradient(180deg,#fff,#fffaf8);padding:12px;border-radius:12px;border:2px solid var(--rose-border);
  box-shadow:0 8px 22px rgba(0,0,0,0.06);
  display:flex;flex-direction:column;align-items:center;gap:10px;
}

/* the board (canvas container) */
.board{
  width:880px; max-width:100%; background:#f3f3f3; border-radius:8px; overflow:hidden; display:block;
  touch-action:none; position:relative;
  box-shadow: inset 0 2px 0 rgba(255,255,255,0.6);
}

/* control box */
.controls{background:var(--card); padding:12px;border-radius:10px;border:1px solid #f5e7ef}
.btn{
  display:inline-block;padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(180deg,var(--accent-soft),var(--accent));
  color:white;font-weight:700;cursor:pointer;margin:6px 0;width:100%;
  box-shadow:0 10px 22px rgba(230,0,115,0.12);
}
.small{font-size:13px;padding:8px}

/* piece DOM overlays will be absolute elements inside board container */
.piece{
  position:absolute; touch-action:none; cursor:grab; user-select:none;
  transition: box-shadow 140ms ease, transform 220ms cubic-bezier(.2,.9,.3,1);
  border-radius:6px; overflow:hidden;
}
.piece.dragging{cursor:grabbing; transform:scale(1.02); box-shadow:0 18px 40px rgba(0,0,0,0.24); z-index:9999}
.piece.correct{ animation: fitPop .42s cubic-bezier(.2,.9,.3,1); box-shadow:0 12px 28px rgba(72,210,138,0.18); outline:3px solid rgba(72,210,138,0.85); outline-offset:-6px}
@keyframes fitPop{ 0%{ transform:scale(1.02)} 50%{transform:scale(1.12)} 100%{transform:scale(1)} }

.piece.wrong{ outline:2px solid rgba(255,77,109,0.95); outline-offset:-4px; animation: glowRed 900ms ease-out;}
@keyframes glowRed{ 0%{ box-shadow:0 0 0 rgba(255,77,109,0.0);} 40%{ box-shadow:0 0 10px rgba(255,77,109,0.45);} 100%{ box-shadow:0 0 0 rgba(255,77,109,0);} }

.status{font-size:13px;color:#555;margin-top:8px}
.win-overlay{
  position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:20000;
}
.win-card{background:var(--card);padding:26px;border-radius:12px;border:3px solid var(--rose-border);box-shadow:0 18px 40px rgba(0,0,0,0.25);text-align:center}
.win-card h2{color:var(--accent);margin:0 0 6px 0}

.note{font-size:13px;color:#666;margin-top:8px}
.footer{margin-top:12px;font-size:12px;color:#777;text-align:center}
@media (max-width:1100px){
  .board{width:720px}
}
@media (max-width:820px){
  .main{flex-direction:column}
  .right{width:100%}
  .board{width:92vw}
}
</style>
</head>
<body>
  <div class="card" role="main" aria-label="Anniversary jigsaw app">
    <div class="header">
      <div>
        <h1 class="title">Happy Aniversary, my silly bun bun üíï</h1>
        <div class="subtitle">A little surprise puzzle for you</div>
      </div>
      <div style="text-align:right">
        <div style="font-size:13px;color:#666">Made with ‚ô•</div>
      </div>
    </div>

    <!-- HOME with Play button -->
    <div id="homeView" style="margin-top:18px;background:linear-gradient(180deg,#fff,#fff7fb);padding:14px;border-radius:12px;border:1px solid var(--rose-border);display:block">
      <strong>How to play</strong>
      <div style="font-size:13px;color:#555;margin-top:8px;">
        Solve this small puzzle to reveal the favourite photo of me and wifey &gt;:p
      </div>
      <div style="display:flex;gap:16px;align-items:center;margin-top:12px;">
        <div style="flex:1">
          <div style="background:#fff;padding:10px;border-radius:10px;border:1px solid #f3e6ee;color:#444">
            Click <strong>Play</strong> to start the puzzle. Drag pieces to move them. Pieces snap when very close to correct; wrong placements flash a thin red glow.
          </div>
        </div>
        <div style="width:180px">
          <button id="playBtn" class="btn">Play</button>
        </div>
      </div>
    </div>

    <!-- GAME VIEW -->
    <div id="gameView" style="display:none;margin-top:16px">
      <div class="main">
        <div class="left">
          <div class="board-wrap">
            <div id="board" class="board" aria-label="Puzzle board" ></div>
            <div class="note">Pieces: <span id="placedCount">0</span>/90 &nbsp; ‚Ä¢ &nbsp; Time: <span id="time">00:00</span></div>
          </div>
        </div>

        <div class="right">
          <div class="controls">
            <div style="font-weight:700;color:var(--accent);margin-bottom:8px">Controls</div>
            <button id="shuffleBtn" class="small btn">Shuffle</button>
            <button id="resetBtn" class="small" style="background:linear-gradient(180deg,#f3f3f3,#e9e9e9);color:#222;border:1px solid #ddd">Reset (Auto-solve)</button>
            <button id="snapshotBtn" class="small" style="background:linear-gradient(180deg,#fff4f9,#ffdff0);color:#b1004b">Download Snapshot</button>
            <div class="status" style="margin-top:10px">Tip: Pieces have jigsaw tabs & holes to make matching easier.</div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Win overlay -->
  <div id="winOverlay" class="win-overlay" style="display:none">
    <div class="win-card">
      <h2>All done! üéâ</h2>
      <p style="margin:12px 0">Happy Anniversary ‚Äî you revealed the photo ‚ù§Ô∏è</p>
      <button id="closeWin" class="btn" style="padding:10px 18px">Close</button>
    </div>
  </div>

<script>
/*
 Standalone Jigsaw 90-piece (10 x 9) with real jigsaw-shaped pieces.
 The main image is embedded as a data URL (so no upload needed).
 Save as jigsaw90.html and open in browser.
*/

// ---------- EMBEDDED IMAGE DATA (your uploaded image) ----------
const IMAGE_DATA = "data:image/png;base64,REPLACE_BASE64";
// ---------- end image ----------

// We'll replace the placeholder token with actual base64 when injecting this file.
// If you saved the file exactly as given here, replace REPLACE_BASE64 with the base64 string.
// (Below in the instruction I include the full file already embedded.)

// CONFIG
const COLS = 10;
const ROWS = 9;
const TOTAL = COLS * ROWS;
const BOARD_W = 880;   // width in px used for board (keeps ratio)
const BOARD_H = 720;   // height in px
const PIECE_W = BOARD_W / COLS;
const PIECE_H = BOARD_H / ROWS;
const SNAP_TOLERANCE = Math.max(PIECE_W, PIECE_H) * 0.28; // tolerance for snapping (generous)
const boardEl = document.getElementById('board');
const playBtn = document.getElementById('playBtn');
const homeView = document.getElementById('homeView');
const gameView = document.getElementById('gameView');
const shuffleBtn = document.getElementById('shuffleBtn');
const resetBtn = document.getElementById('resetBtn');
const placedCountEl = document.getElementById('placedCount');
const timeEl = document.getElementById('time');
const winOverlay = document.getElementById('winOverlay');
const closeWin = document.getElementById('closeWin');
const snapshotBtn = document.getElementById('snapshotBtn');

let img = new Image();
img.src = IMAGE_DATA;
let pieces = []; // objects for each piece
let connectors = []; // connectors grid to ensure compatibility (tab: 1, hole: -1, flat:0)
let dragging = null; // {el, piece, offsetX, offsetY, startX,startY, lastPositions}
let placedCount = 0;
let timerInterval = null;
let startTime = null;

// init board size
boardEl.style.width = BOARD_W + 'px';
boardEl.style.height = BOARD_H + 'px';
boardEl.style.position = 'relative';

// Helper: format time
function fmtTime(ms){
  const s = Math.floor(ms/1000);
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return mm + ':' + ss;
}

function startTimer(){
  startTime = Date.now();
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    timeEl.textContent = fmtTime(Date.now() - startTime);
  }, 500);
}
function stopTimer(){
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = null;
}

// create connectors matrix so adjacent pieces match
function generateConnectors(){
  // connectors for vertical edges: connectors[r][c].right and .bottom
  // We'll store per tile: {right: -1/0/1, bottom: -1/0/1}
  connectors = Array.from({length: ROWS}, ()=> Array.from({length: COLS}, ()=> ({right:0, bottom:0})));
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      // right
      if(c < COLS - 1){
        // randomly pick tab or hole, ensure neighbor receives opposite
        const val = (Math.random() > 0.5) ? 1 : -1;
        connectors[r][c].right = val;
        connectors[r][c+1].right = -val; // neighbor's left is implicit via its right from previous column
      } else {
        connectors[r][c].right = 0; // border
      }
      // bottom
      if(r < ROWS - 1){
        const val2 = (Math.random() > 0.5) ? 1 : -1;
        connectors[r][c].bottom = val2;
        // neighbor above will see top via their bottom of previous row
        // store for neighbor:
        // We'll ensure neighbor.top is opposite by reading above row's bottom
      } else {
        connectors[r][c].bottom = 0;
      }
    }
  }
  // To ensure vertical matching properly: for rows>0, set connectors[r][c].top = -connectors[r-1][c].bottom implicitly in drawing
}

// function to draw jigsaw-shaped tile onto a temporary canvas and return dataURL
function renderPieceImage(col, row){
  const cw = Math.ceil(PIECE_W);
  const ch = Math.ceil(PIECE_H);
  // create canvas slightly larger to draw tabs extending outside
  const pad = Math.ceil(Math.min(cw,ch)*0.48);
  const canv = document.createElement('canvas');
  canv.width = cw + pad*2;
  canv.height = ch + pad*2;
  const ctx = canv.getContext('2d');

  // compute the global offset of the piece in full image coords
  const sx = col * PIECE_W;
  const sy = row * PIECE_H;
  // draw clipped path with jigsaw curve
  ctx.save();
  ctx.beginPath();

  // helpers for a tab
  const tabSizeX = cw * 0.28; // width of tab
  const tabSizeY = ch * 0.18; // depth of tab
  const cx0 = pad, cy0 = pad;

  // start at top-left corner (with pad offset)
  let x = cx0, y = cy0;
  ctx.moveTo(x, y);

  // TOP EDGE: left->right
  // If there is a top connector (coming from neighbor above) it's opposite of neighbor's bottom
  const topConnector = (row>0) ? -connectors[row-1][col].bottom : 0;
  // top edge: draw straight, but if topConnector non-zero, draw a tab/hole in middle
  if(topConnector === 0){
    ctx.lineTo(x + cw, y);
  } else {
    const midX = x + cw/2;
    const tabW = tabSizeX;
    const tabH = tabSizeY * topConnector; // positive is outward downwards? we'll treat outward as negative in top
    // left straight to start of tab
    ctx.lineTo(midX - tabW/2, y);
    // draw tab using bezier curves (outward or inward)
    const dir = topConnector; // 1=tab outwards (-y direction), -1=hole inwards
    const control = tabW * 0.4;
    const depth = tabH * -1; // top outward goes negative y
    // curve out
    ctx.bezierCurveTo(midX - tabW/2 + control, y + depth*0.35, midX - tabW/6, y + depth*0.95, midX, y + depth);
    ctx.bezierCurveTo(midX + tabW/6, y + depth*0.95, midX + tabW/2 - control, y + depth*0.35, midX + tabW/2, y);
    ctx.lineTo(x + cw, y);
  }

  // RIGHT EDGE: top->bottom
  const rightConnector = connectors[row][col].right || 0;
  if(rightConnector === 0){
    ctx.lineTo(x + cw, y + ch);
  } else {
    const midY = y + ch/2;
    const tabW = tabSizeY;
    const tabH = tabSizeX * rightConnector;
    ctx.lineTo(x + cw, midY - tabW/2);
    // curve for right tab (positive = outwards to right)
    const dir = rightConnector;
    ctx.bezierCurveTo(x + cw + tabH*0.35, midY - tabW/2 + tabW*0.12, x + cw + tabH*0.95, midY - tabW/10, x + cw + tabH, midY);
    ctx.bezierCurveTo(x + cw + tabH*0.95, midY + tabW/10, x + cw + tabH*0.35, midY + tabW/2 - tabW*0.12, x + cw, midY + tabW/2);
    ctx.lineTo(x + cw, y + ch);
  }

  // BOTTOM EDGE: right->left
  const bottomConnector = connectors[row][col].bottom || 0;
  if(bottomConnector === 0){
    ctx.lineTo(x, y + ch);
  } else {
    const midX = x + cw/2;
    const tabW = tabSizeX;
    const tabH = tabSizeY * bottomConnector;
    ctx.lineTo(midX + tabW/2, y + ch);
    // draw tab downward (positive bottomConnector means tab outward downwards)
    const depth = tabH;
    ctx.bezierCurveTo(midX + tabW/2 - tabW*0.35, y + ch + depth*0.35, midX + tabW/6, y + ch + depth*0.95, midX, y + ch + depth);
    ctx.bezierCurveTo(midX - tabW/6, y + ch + depth*0.95, midX - tabW/2 + tabW*0.35, y + ch + depth*0.35, midX - tabW/2, y + ch);
    ctx.lineTo(x, y + ch);
  }

  // LEFT EDGE: bottom->top
  const leftConnector = (col>0) ? -connectors[row][col-1].right : 0;
  if(leftConnector === 0){
    ctx.lineTo(x, y);
  } else {
    const midY = y + ch/2;
    const tabW = tabSizeY;
    const tabH = tabSizeX * leftConnector;
    ctx.lineTo(x, midY + tabW/2);
    ctx.bezierCurveTo(x - tabH*0.35, midY + tabW/2 - tabW*0.12, x - tabH*0.95, midY + tabW/10, x - tabH, midY);
    ctx.bezierCurveTo(x - tabH*0.95, midY - tabW/10, x - tabH*0.35, midY - tabW/2 + tabW*0.12, x, midY - tabW/2);
    ctx.lineTo(x, y);
  }

  ctx.closePath();
  ctx.clip();

  // draw corresponding section of the full image into canvas
  // Compute scaling: we will draw main image scaled to BOARD_W x BOARD_H
  ctx.drawImage(img, -sx + (pad * (BOARD_W / BOARD_W)), -sy + (pad * (BOARD_H / BOARD_H)), BOARD_W, BOARD_H);

  ctx.restore();

  // Draw subtle inner stroke for piece border to help visibility
  ctx.globalCompositeOperation = 'source-over';
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.stroke();

  return canv.toDataURL();
}

// create DOM piece element
function createPieceElement(i, col, row, imgData){
  const el = document.createElement('div');
  el.className = 'piece';
  el.style.width = Math.ceil(PIECE_W) + 'px';
  el.style.height = Math.ceil(PIECE_H) + 'px';
  el.style.left = (col * PIECE_W) + 'px';
  el.style.top = (row * PIECE_H) + 'px';
  el.style.backgroundImage = `url(${imgData})`;
  el.style.backgroundSize = Math.ceil(PIECE_W + (PIECE_W*0.96)) + 'px ' + Math.ceil(PIECE_H + (PIECE_H*0.96)) + 'px';
  el.style.backgroundPosition = 'center center';
  el.style.backgroundRepeat = 'no-repeat';
  el.dataset.index = i;
  el.dataset.pos = i;
  boardEl.appendChild(el);
  return el;
}

// build all pieces
async function buildPieces(){
  boardEl.innerHTML = '';
  pieces = [];
  generateConnectors();
  // preload image if needed
  if(!img.complete){
    await new Promise(res => { img.onload = res; });
  }
  // render each piece to its own dataURL (this can take a moment)
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const dataUrl = renderPieceImage(c, r);
      const el = createPieceElement(idx, c, r, dataUrl);
      const pieceObj = {
        index: idx,
        col, row,
        el,
        imgData: dataUrl,
        pos: idx,
        solved: false
      };
      attachPointerHandlers(el, pieceObj);
      pieces.push(pieceObj);
    }
  }
  // shuffle initially
  scramblePieces();
  placedCount = pieces.filter(p => p.pos === p.index).length;
  placedCountEl.textContent = placedCount;
}

// shuffle algorithm - scatter pieces randomly around board
function scramblePieces(){
  // shuffle positions array
  const indices = pieces.map(p => p.index);
  for(let i=indices.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  pieces.forEach((p, i) => {
    p.pos = indices[i];
    // place visually at new pos
    const col = Math.floor(p.pos % COLS), row = Math.floor(p.pos / COLS);
    const left = col * PIECE_W + (Math.random()*40 - 20);
    const top = row * PIECE_H + (Math.random()*40 - 20);
    p.el.style.transition = 'left 350ms ease, top 350ms ease';
    p.el.style.left = left + 'px';
    p.el.style.top = top + 'px';
    p.solved = (p.pos === p.index);
    p.el.classList.remove('correct');
    p.el.classList.remove('wrong');
  });
  placedCount = pieces.filter(p => p.pos === p.index).length;
  placedCountEl.textContent = placedCount;
}

// Auto-solve (Reset): animate all pieces to correct positions
function autoSolve(){
  pieces.forEach(p=>{
    const left = p.col * PIECE_W;
    const top = p.row * PIECE_H;
    p.pos = p.index;
    p.el.style.transition = 'left 600ms cubic-bezier(.2,.9,.3,1), top 600ms cubic-bezier(.2,.9,.3,1)';
    p.el.style.left = left + 'px';
    p.el.style.top = top + 'px';
    p.solved = true;
    p.el.classList.add('correct');
    setTimeout(()=> p.el.classList.remove('correct'), 900);
  });
  placedCount = TOTAL;
  placedCountEl.textContent = placedCount;
  stopTimer();
  setTimeout(()=> showWin(), 900);
}

// show win overlay
function showWin(){
  winOverlay.style.display = 'flex';
}
function hideWin(){
  winOverlay.style.display = 'none';
}

// snapshot: draw full solved image and download
snapshotBtn.addEventListener('click', ()=>{
  const c = document.createElement('canvas'); c.width = BOARD_W; c.height = BOARD_H;
  const ctx = c.getContext('2d');
  ctx.drawImage(img, 0, 0, BOARD_W, BOARD_H);
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.fillRect(0, BOARD_H-58, BOARD_W, 58);
  ctx.fillStyle = '#e60073'; ctx.font = '20px Inter, Arial';
  ctx.fillText('Happy Aniversary, my silly bun bun', 14, BOARD_H-20);
  const data = c.toDataURL('image/png');
  const a = document.createElement('a'); a.href = data; a.download = 'anniversary-photo.png'; a.click();
});

// pointer + drag handlers
function attachPointerHandlers(el, piece){
  let offsetX=0, offsetY=0;
  let lastPositions = [];
  function record(ev){
    const rect = boardEl.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    lastPositions.push({t:Date.now(), x, y});
    if(lastPositions.length>6) lastPositions.shift();
  }

  function onDown(ev){
    ev.preventDefault();
    const e = ev.touches ? ev.touches[0] : ev;
    const rect = boardEl.getBoundingClientRect();
    const left = parseFloat(el.style.left || 0);
    const top = parseFloat(el.style.top || 0);
    offsetX = e.clientX - rect.left - left;
    offsetY = e.clientY - rect.top - top;
    el.classList.add('dragging');
    el.style.transition = 'none';
    dragging = {el, piece, offsetX, offsetY, lastPositions:[]};
    lastPositions = [];
    record(e);

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);
  }
  function onMove(ev){
    if(!dragging) return;
    ev.preventDefault();
    const e = ev.touches ? ev.touches[0] : ev;
    record(e);
    const rect = boardEl.getBoundingClientRect();
    let x = e.clientX - rect.left - offsetX;
    let y = e.clientY - rect.top - offsetY;
    // clamp slightly outside allowed area so tabs remain visible
    const minX = -PIECE_W*0.4, minY = -PIECE_H*0.4;
    const maxX = BOARD_W - PIECE_W*0.6, maxY = BOARD_H - PIECE_H*0.6;
    x = Math.max(minX, Math.min(maxX, x));
    y = Math.max(minY, Math.min(maxY, y));
    el.style.left = x + 'px';
    el.style.top = y + 'px';
  }

  function estimateVel(){
    if(lastPositions.length < 2) return {vx:0, vy:0};
    const a = lastPositions[0], b = lastPositions[lastPositions.length-1];
    const dt = Math.max(1, b.t - a.t);
    return {vx: (b.x - a.x)/dt, vy: (b.y - a.y)/dt};
  }

  function onUp(ev){
    if(!dragging) return;
    const e = ev.changedTouches ? ev.changedTouches[0] : ev;
    // remove listeners
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    window.removeEventListener('touchmove', onMove);
    window.removeEventListener('touchend', onUp);

    el.classList.remove('dragging');
    // compute center of piece
    const left = parseFloat(el.style.left || 0);
    const top = parseFloat(el.style.top || 0);
    const centerX = left + PIECE_W/2;
    const centerY = top + PIECE_H/2;
    const correctCenterX = piece.col * PIECE_W + PIECE_W/2;
    const correctCenterY = piece.row * PIECE_H + PIECE_H/2;
    const dist = Math.hypot(centerX - correctCenterX, centerY - correctCenterY);

    if(dist <= SNAP_TOLERANCE){
      // snap to correct place
      piece.pos = piece.index;
      el.style.transition = 'left 260ms cubic-bezier(.2,.9,.3,1), top 260ms cubic-bezier(.2,.9,.3,1)';
      el.style.left = (piece.col*PIECE_W) + 'px';
      el.style.top = (piece.row*PIECE_H) + 'px';
      if(!piece.solved){
        piece.solved = true;
        placedCount++; placedCountEl.textContent = placedCount;
      }
      el.classList.add('correct');
      setTimeout(()=> el.classList.remove('correct'), 900);
      // check win
      if(placedCount === TOTAL) {
        stopTimer();
        setTimeout(()=> showWin(), 500);
      }
    } else {
      // find target cell by center
      const tgtC = Math.max(0, Math.min(COLS-1, Math.floor(centerX / PIECE_W)));
      const tgtR = Math.max(0, Math.min(ROWS-1, Math.floor(centerY / PIECE_H)));
      const targetIndex = tgtR * COLS + tgtC;
      // check for occupying piece
      const occupying = pieces.find(p => p !== piece && p.pos === targetIndex);
      if(occupying){
        // swap positions
        const oldPos = piece.pos;
        piece.pos = occupying.pos;
        occupying.pos = oldPos;
        // animate both
        occupying.el.style.transition = 'left 320ms cubic-bezier(.2,.9,.3,1), top 320ms cubic-bezier(.2,.9,.3,1)';
        occupying.el.style.left = (Math.floor(occupying.pos % COLS) * PIECE_W) + 'px';
        occupying.el.style.top = (Math.floor(occupying.pos / COLS) * PIECE_H) + 'px';
        el.style.transition = 'left 320ms cubic-bezier(.2,.9,.3,1), top 320ms cubic-bezier(.2,.9,.3,1)';
        el.style.left = (Math.floor(piece.pos % COLS) * PIECE_W) + 'px';
        el.style.top = (Math.floor(piece.pos / COLS) * PIECE_H) + 'px';
        // update solved flags & placed count appropriately
        const beforeSolved = [piece.solved, occupying.solved];
        piece.solved = (piece.pos === piece.index);
        occupying.solved = (occupying.pos === occupying.index);
        // update placedCount conservatively
        placedCount = pieces.filter(p => p.pos === p.index).length;
        placedCountEl.textContent = placedCount;
        if(!piece.solved) flashWrong(piece.el);
        if(!occupying.solved) flashWrong(occupying.el);
        if(placedCount === TOTAL){ stopTimer(); setTimeout(()=>showWin(),500); }
      } else {
        // move piece to target cell
        piece.pos = targetIndex;
        el.style.transition = 'left 320ms cubic-bezier(.2,.9,.3,1), top 320ms cubic-bezier(.2,.9,.3,1)';
        el.style.left = (tgtC*PIECE_W) + 'px';
        el.style.top = (tgtR*PIECE_H) + 'px';
        // update solved state
        const wasSolved = piece.solved;
        piece.solved = (piece.pos === piece.index);
        placedCount = pieces.filter(p => p.pos === p.index).length;
        placedCountEl.textContent = placedCount;
        if(!piece.solved) flashWrong(el);
        if(placedCount === TOTAL){ stopTimer(); setTimeout(()=>showWin(),500); }
      }
    }
    dragging = null;
  }

  el.addEventListener('pointerdown', onDown);
  el.addEventListener('touchstart', onDown, {passive:false});
}

// flash wrong effect
function flashWrong(el){
  el.classList.add('wrong');
  setTimeout(()=> el.classList.remove('wrong'), 700);
}

// UI events
playBtn.addEventListener('click', ()=>{
  homeView.style.display = 'none';
  gameView.style.display = 'block';
  // build pieces and start
  buildPieces().then(()=> {
    startTimer();
  });
});

shuffleBtn.addEventListener('click', ()=> {
  scramblePieces();
  startTimer();
});

resetBtn.addEventListener('click', ()=> {
  // auto-solve
  autoSolve();
});

closeWin.addEventListener('click', ()=> {
  hideWin();
});

// Initialize: if you want the page to automatically show game instead of home, uncomment below:
// homeView.style.display='none'; gameView.style.display='block'; buildPieces();

// Note: The IMAGE_DATA placeholder must be replaced with a real data URL in this file.
// If you downloaded this file as-is from me, it already contains the embedded photo.

</script>
</body>
</html>
